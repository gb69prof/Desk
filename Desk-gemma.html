<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ThinkDesk | AI Powered Workspace</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base Setup */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #f3f4f6; touch-action: none; font-family: 'Segoe UI', system-ui, sans-serif; }
        
        /* The Viewport */
        #viewport { width: 100vw; height: 100vh; overflow: hidden; position: relative; cursor: grab; }
        #viewport:active { cursor: grabbing; }
        
        /* The World (Transform Layer) */
        #world { position: absolute; top: 0; left: 0; transform-origin: 0 0; will-change: transform; width: 0; height: 0; }
        
        /* SVG Connections Layer */
        #connections-layer { position: absolute; overflow: visible; pointer-events: none; z-index: 0; }
        
        /* Cards */
        .card {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            border: 1px solid #e5e7eb;
            transition: box-shadow 0.2s, border-color 0.2s;
            user-select: none;
            touch-action: none;
            min-width: 150px;
            min-height: 100px;
            z-index: 10;
        }
        
        .card.selected { border: 2px solid #3b82f6; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); z-index: 20; }
        .card-header { height: 24px; background: #f9fafb; border-bottom: 1px solid #e5e7eb; border-radius: 8px 8px 0 0; cursor: move; display: flex; justify-content: flex-end; padding: 0 4px; align-items: center; }
        .card-body { flex: 1; padding: 8px; overflow: hidden; position: relative; }
        .card-resize { position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: se-resize; background: linear-gradient(135deg, transparent 50%, #cbd5e1 50%); border-radius: 0 0 8px 0; }
        
        /* Content Types */
        .content-text { width: 100%; height: 100%; outline: none; white-space: pre-wrap; overflow-y: auto; font-size: 14px; cursor: text; }
        .content-img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .content-iframe { width: 100%; height: 100%; border: none; pointer-events: none; } /* No interaction in desk mode */
        
        /* Toolbar */
        #toolbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
            padding: 8px 16px; border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            display: flex; gap: 12px; z-index: 1000; border: 1px solid #e5e7eb; align-items: center;
        }
        
        .tool-btn {
            width: 44px; height: 44px; border-radius: 10px; border: none; background: transparent;
            color: #4b5563; font-size: 20px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s; position: relative;
        }
        
        .tool-btn:hover { background: #f3f4f6; color: #111827; }
        .tool-btn.active { background: #eff6ff; color: #2563eb; }
        
        /* AI Button Special Style */
        #btn-ai { color: #7c3aed; }
        #btn-ai:hover { background: #f5f3ff; color: #6d28d9; }
        #btn-ai.loading { animation: pulse 1.5s infinite; opacity: 0.7; pointer-events: none; }
        
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(0.95); } 100% { transform: scale(1); } }

        /* AI Popup */
        #ai-popup {
            position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: white; width: 300px; padding: 16px; border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1001; display: none; flex-direction: column; gap: 10px; border: 1px solid #e5e7eb;
        }
        .ai-option-btn {
            background: #f3f4f6; border: none; padding: 8px; border-radius: 6px; cursor: pointer; text-align: left; font-size: 14px; color: #374151; transition: background 0.2s;
        }
        .ai-option-btn:hover { background: #e5e7eb; }
        .ai-input { width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; margin-bottom: 8px; font-size: 14px; }
        
        /* Modal for expansion */
        #modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 2000; display: none; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        #modal-content { background: white; width: 90%; height: 90%; border-radius: 12px; overflow: hidden; position: relative; display: flex; flex-direction: column; }
        #modal-close { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.1); border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; z-index: 10; font-weight: bold; }
        
        /* Helpers */
        .hidden { display: none !important; }
        
        /* Grid Background pattern */
        #grid-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px; opacity: 0.5; pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- Main Viewport -->
    <div id="viewport">
        <div id="grid-bg"></div>
        <div id="world">
            <svg id="connections-layer" width="1" height="1"></svg>
            <!-- Cards go here -->
        </div>
    </div>

    <!-- Toolbar -->
    <div id="toolbar">
        <button class="tool-btn" id="btn-text" title="Aggiungi Testo">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg>
        </button>
        <button class="tool-btn" id="btn-img" title="Aggiungi Immagine">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>
        </button>
        <button class="tool-btn" id="btn-web" title="Aggiungi Sito/Embed">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
        </button>
        
        <!-- AI BUTTON -->
        <button class="tool-btn" id="btn-ai" title="Magic AI ‚ú®">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
        </button>

        <div class="w-px h-8 bg-gray-300 mx-1 self-center"></div>
        <button class="tool-btn" id="btn-connect" title="Modalit√† Connetti">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>
        </button>
        <button class="tool-btn" id="btn-delete-mode" title="Modalit√† Elimina">
             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        </button>
        <div class="w-px h-8 bg-gray-300 mx-1 self-center"></div>
        <button class="tool-btn" id="btn-save" title="Salva LocalStorage">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
        </button>
        <button class="tool-btn" id="btn-export" title="Esporta JSON">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
        </button>
        <button class="tool-btn" id="btn-import" title="Importa JSON" onclick="document.getElementById('file-input').click()">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
        </button>
        <input type="file" id="file-input" class="hidden" accept=".json">
        <button class="tool-btn text-red-500" id="btn-clear" title="Svuota Desk">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
    </div>

    <!-- AI Popup Menu -->
    <div id="ai-popup">
        <h3 class="font-bold text-gray-700 text-sm mb-2">‚ú® Gemini AI Tools</h3>
        
        <!-- Section: No Card Selected (Brainstorming) -->
        <div id="ai-brainstorm-section">
            <p class="text-xs text-gray-500 mb-2">Genera idee su un argomento:</p>
            <input type="text" id="ai-topic-input" class="ai-input" placeholder="Es: Piani marketing 2024...">
            <button class="ai-option-btn w-full bg-indigo-50 text-indigo-700 font-medium" onclick="runBrainstorm()">üöÄ Genera Idee (Brainstorming)</button>
        </div>

        <!-- Section: Text Card Selected -->
        <div id="ai-text-section" class="hidden">
            <p class="text-xs text-gray-500 mb-2">Modifica la card selezionata:</p>
            <div class="flex flex-col gap-1">
                <button class="ai-option-btn" onclick="runTextAI('expand')">üìù Espandi contenuto</button>
                <button class="ai-option-btn" onclick="runTextAI('summarize')">ü§è Riassumi (Bullet points)</button>
                <button class="ai-option-btn" onclick="runTextAI('professional')">üëî Riscrivi Professional</button>
            </div>
        </div>
        
        <div id="ai-loading" class="hidden text-center py-2 text-indigo-600 text-sm">
            ‚ú® Gemini sta pensando...
        </div>
    </div>

    <!-- Expansion Modal -->
    <div id="modal-overlay">
        <div id="modal-content">
            <button id="modal-close">X</button>
            <div id="modal-body" class="w-full h-full p-4 overflow-auto"></div>
        </div>
    </div>

    <script>
        // --- Gemini Configuration ---
        const apiKey = ""; // Injected by environment
        const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        async function callGemini(prompt, systemInstruction = "Sei un assistente creativo utile.") {
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] }
            };

            try {
                const response = await fetch(GEMINI_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) throw new Error("API Error");
                
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "Errore nella generazione.";
            } catch (error) {
                console.error(error);
                alert("Errore di connessione a Gemini AI. Riprova.");
                return null;
            }
        }

        // --- State Management ---
        const state = {
            pan: { x: 0, y: 0 },
            scale: 1,
            mode: 'move', // move, connect, delete
            isDragging: false,
            isPanning: false,
            startPan: { x: 0, y: 0 },
            cards: [],
            connections: [],
            nextId: 1,
            selectedCard: null,
            connectSource: null
        };

        const DOM = {
            viewport: document.getElementById('viewport'),
            world: document.getElementById('world'),
            svgLayer: document.getElementById('connections-layer'),
            grid: document.getElementById('grid-bg'),
            btns: document.querySelectorAll('.tool-btn'),
            aiPopup: document.getElementById('ai-popup'),
            aiBtn: document.getElementById('btn-ai')
        };

        // --- Core: Infinite Desk Logic ---

        function updateTransform() {
            DOM.world.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.scale})`;
            DOM.grid.style.backgroundPosition = `${state.pan.x}px ${state.pan.y}px`;
            DOM.grid.style.backgroundSize = `${20 * state.scale}px ${20 * state.scale}px`;
        }

        DOM.viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.ctrlKey || e.metaKey) {
                const zoomIntensity = 0.1;
                const delta = -Math.sign(e.deltaY) * zoomIntensity;
                const oldScale = state.scale;
                let newScale = Math.min(Math.max(0.1, state.scale + delta), 5);
                
                const rect = DOM.viewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const worldX = (mouseX - state.pan.x) / oldScale;
                const worldY = (mouseY - state.pan.y) / oldScale;
                
                state.pan.x = mouseX - worldX * newScale;
                state.pan.y = mouseY - worldY * newScale;
                state.scale = newScale;
            } else {
                state.pan.x -= e.deltaX;
                state.pan.y -= e.deltaY;
            }
            updateTransform();
        }, { passive: false });

        DOM.viewport.addEventListener('pointerdown', (e) => {
            // Close AI popup if clicking outside
            if (!DOM.aiPopup.contains(e.target) && e.target !== DOM.aiBtn && !DOM.aiBtn.contains(e.target)) {
                DOM.aiPopup.style.display = 'none';
                DOM.aiBtn.classList.remove('active');
            }

            // Deselect card if clicking background
            if (e.target === DOM.viewport || e.target === DOM.grid || e.target.id === 'connections-layer') {
                if(state.selectedCard) {
                    const el = document.getElementById(`card-${state.selectedCard}`);
                    if(el) el.classList.remove('selected');
                    state.selectedCard = null;
                }
            }

            if (e.target !== DOM.viewport && e.target !== DOM.grid && e.target.id !== 'connections-layer') return;
            state.isPanning = true;
            state.startPan = { x: e.clientX - state.pan.x, y: e.clientY - state.pan.y };
            DOM.viewport.setPointerCapture(e.pointerId);
        });

        DOM.viewport.addEventListener('pointermove', (e) => {
            if (!state.isPanning) return;
            state.pan.x = e.clientX - state.startPan.x;
            state.pan.y = e.clientY - state.startPan.y;
            updateTransform();
        });

        DOM.viewport.addEventListener('pointerup', (e) => {
            state.isPanning = false;
            DOM.viewport.releasePointerCapture(e.pointerId);
        });

        // --- Card Management ---

        function createCard(type, content = null, x = null, y = null, w = 200, h = 150, id = null) {
            const cardId = id || state.nextId++;
            
            if (x === null) {
                const rect = DOM.viewport.getBoundingClientRect();
                x = (-state.pan.x + (rect.width / 2)) / state.scale - (w / 2);
                y = (-state.pan.y + (rect.height / 2)) / state.scale - (h / 2);
            }

            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.id = `card-${cardId}`;
            cardEl.style.left = `${x}px`;
            cardEl.style.top = `${y}px`;
            cardEl.style.width = `${w}px`;
            cardEl.style.height = `${h}px`;
            cardEl.dataset.id = cardId;

            const cardData = { id: cardId, type, content, x, y, w, h };
            state.cards.push(cardData);

            const header = document.createElement('div');
            header.className = 'card-header';
            
            const expandBtn = document.createElement('div');
            expandBtn.innerHTML = '‚§¢';
            expandBtn.style.cursor = 'pointer';
            expandBtn.style.marginRight = 'auto';
            expandBtn.style.padding = '0 5px';
            expandBtn.title = "Espandi";
            expandBtn.onclick = (e) => { e.stopPropagation(); openModal(cardData); };
            
            header.appendChild(expandBtn);
            cardEl.appendChild(header);

            const body = document.createElement('div');
            body.className = 'card-body';
            
            if (type === 'text') {
                const textarea = document.createElement('div');
                textarea.className = 'content-text';
                textarea.contentEditable = true;
                textarea.innerText = content || 'Nuova nota...';
                textarea.addEventListener('pointerdown', (e) => e.stopPropagation());
                textarea.addEventListener('input', () => { cardData.content = textarea.innerText; });
                body.appendChild(textarea);
            } else if (type === 'img') {
                const img = document.createElement('img');
                img.className = 'content-img';
                img.src = content || 'https://via.placeholder.com/300';
                img.onerror = () => { img.src = 'https://via.placeholder.com/300?text=Error'; };
                body.appendChild(img);
            } else if (type === 'web') {
                const iframe = document.createElement('iframe');
                iframe.className = 'content-iframe';
                iframe.src = content || 'about:blank';
                const overlay = document.createElement('div');
                overlay.style.position = 'absolute';
                overlay.style.inset = '0';
                body.appendChild(iframe);
                body.appendChild(overlay);
            }

            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'card-resize';
            body.appendChild(resizeHandle);
            
            cardEl.appendChild(body);
            DOM.world.appendChild(cardEl);

            // Card Selection Logic (for AI)
            cardEl.addEventListener('pointerdown', (e) => {
                // Select logic
                if (state.selectedCard && state.selectedCard !== cardId) {
                    document.getElementById(`card-${state.selectedCard}`).classList.remove('selected');
                }
                state.selectedCard = cardId;
                cardEl.classList.add('selected');
                
                // If AI popup is open, refresh it to show relevant options
                if(DOM.aiPopup.style.display === 'flex') {
                    showAIOptions();
                }

                if(state.mode === 'delete') {
                    deleteCard(cardId);
                    return;
                }
                if(state.mode === 'connect') {
                    handleConnectionStart(cardId, cardEl);
                    return;
                }

                e.stopPropagation();
                cardEl.setPointerCapture(e.pointerId);
                const startX = e.clientX;
                const startY = e.clientY;
                const initialLeft = parseFloat(cardEl.style.left);
                const initialTop = parseFloat(cardEl.style.top);

                const onMove = (moveEvent) => {
                    const dx = (moveEvent.clientX - startX) / state.scale;
                    const dy = (moveEvent.clientY - startY) / state.scale;
                    
                    const newX = initialLeft + dx;
                    const newY = initialTop + dy;
                    
                    cardEl.style.left = `${newX}px`;
                    cardEl.style.top = `${newY}px`;
                    
                    cardData.x = newX;
                    cardData.y = newY;
                    
                    updateConnections();
                };

                const onUp = () => {
                    cardEl.removeEventListener('pointermove', onMove);
                    cardEl.removeEventListener('pointerup', onUp);
                    cardEl.releasePointerCapture(e.pointerId);
                };

                cardEl.addEventListener('pointermove', onMove);
                cardEl.addEventListener('pointerup', onUp);
            });

            resizeHandle.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                resizeHandle.setPointerCapture(e.pointerId);
                
                const startX = e.clientX;
                const startY = e.clientY;
                const startW = parseFloat(cardEl.style.width);
                const startH = parseFloat(cardEl.style.height);

                const onResize = (moveEvent) => {
                    const dx = (moveEvent.clientX - startX) / state.scale;
                    const dy = (moveEvent.clientY - startY) / state.scale;
                    
                    const newW = Math.max(100, startW + dx);
                    const newH = Math.max(80, startH + dy);
                    
                    cardEl.style.width = `${newW}px`;
                    cardEl.style.height = `${newH}px`;
                    
                    cardData.w = newW;
                    cardData.h = newH;
                    updateConnections();
                };

                const onUp = () => {
                    resizeHandle.removeEventListener('pointermove', onResize);
                    resizeHandle.removeEventListener('pointerup', onUp);
                    resizeHandle.releasePointerCapture(e.pointerId);
                };

                resizeHandle.addEventListener('pointermove', onResize);
                resizeHandle.addEventListener('pointerup', onUp);
            });
            
            cardEl.addEventListener('click', (e) => {
                if(state.mode === 'delete') {
                    e.stopPropagation();
                    deleteCard(cardId);
                }
            });

            return cardData;
        }

        function deleteCard(id) {
            const el = document.getElementById(`card-${id}`);
            if (el) el.remove();
            state.cards = state.cards.filter(c => c.id !== id);
            state.connections = state.connections.filter(c => c.from !== id && c.to !== id);
            if(state.selectedCard === id) state.selectedCard = null;
            renderConnections();
        }

        // --- Connection Logic ---

        function handleConnectionStart(cardId, cardEl) {
            if (state.connectSource === null) {
                state.connectSource = cardId;
                cardEl.classList.add('selected');
            } else {
                if (state.connectSource !== cardId) {
                    addConnection(state.connectSource, cardId);
                }
                const prev = document.getElementById(`card-${state.connectSource}`);
                if (prev) prev.classList.remove('selected');
                state.connectSource = null;
            }
        }

        function addConnection(fromId, toId) {
            const exists = state.connections.find(c => 
                (c.from === fromId && c.to === toId) || (c.from === toId && c.to === fromId)
            );
            if (!exists) {
                state.connections.push({ from: fromId, to: toId, color: '#94a3b8' });
                renderConnections();
            }
        }

        function renderConnections() {
            DOM.svgLayer.innerHTML = '';
            DOM.svgLayer.style.overflow = 'visible'; 

            state.connections.forEach((conn, index) => {
                const c1 = state.cards.find(c => c.id === conn.from);
                const c2 = state.cards.find(c => c.id === conn.to);
                if (!c1 || !c2) return;

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                
                const x1 = c1.x + c1.w / 2;
                const y1 = c1.y + c1.h / 2;
                const x2 = c2.x + c2.w / 2;
                const y2 = c2.y + c2.h / 2;

                line.setAttribute("x1", x1);
                line.setAttribute("y1", y1);
                line.setAttribute("x2", x2);
                line.setAttribute("y2", y2);
                line.setAttribute("stroke", conn.color);
                line.setAttribute("stroke-width", "3");
                line.style.pointerEvents = "visibleStroke";
                line.style.cursor = "pointer";

                line.addEventListener('click', (e) => {
                    if (state.mode === 'delete') {
                        e.stopPropagation();
                        state.connections.splice(index, 1);
                        renderConnections();
                    }
                });

                DOM.svgLayer.appendChild(line);
            });
        }

        function updateConnections() {
            requestAnimationFrame(renderConnections);
        }

        // --- Toolbar Actions ---

        function setMode(mode) {
            state.mode = mode;
            DOM.btns.forEach(b => b.classList.remove('active'));
            if (mode === 'connect') document.getElementById('btn-connect').classList.add('active');
            if (mode === 'delete') document.getElementById('btn-delete-mode').classList.add('active');
            
            DOM.viewport.style.cursor = mode === 'delete' ? 'crosshair' : 'grab';
            
            if (mode !== 'connect' && state.connectSource) {
                 const prev = document.getElementById(`card-${state.connectSource}`);
                 if (prev) prev.classList.remove('selected');
                 state.connectSource = null;
            }
        }

        document.getElementById('btn-text').onclick = () => { setMode('move'); createCard('text'); };
        
        document.getElementById('btn-img').onclick = () => {
            setMode('move');
            const url = prompt("Inserisci URL immagine:", "https://images.unsplash.com/photo-1517849845537-4d257902454a?w=400");
            if (url) createCard('img', url);
        };
        
        document.getElementById('btn-web').onclick = () => {
            setMode('move');
            const url = prompt("Inserisci URL pagina o Video Embed:", "https://www.wikipedia.org");
            if (url) createCard('web', url);
        };

        document.getElementById('btn-connect').onclick = () => {
            setMode(state.mode === 'connect' ? 'move' : 'connect');
        };

        document.getElementById('btn-delete-mode').onclick = () => {
            setMode(state.mode === 'delete' ? 'move' : 'delete');
        };

        document.getElementById('btn-clear').onclick = () => {
            if(confirm("Vuoi davvero svuotare il desk?")) {
                DOM.world.innerHTML = '<svg id="connections-layer" width="1" height="1"></svg>';
                DOM.svgLayer = document.getElementById('connections-layer');
                state.cards = [];
                state.connections = [];
                state.pan = {x: 0, y: 0};
                state.scale = 1;
                updateTransform();
            }
        };

        // --- AI Logic ---
        
        DOM.aiBtn.onclick = (e) => {
            e.stopPropagation();
            const isOpen = DOM.aiPopup.style.display === 'flex';
            if(isOpen) {
                DOM.aiPopup.style.display = 'none';
                DOM.aiBtn.classList.remove('active');
            } else {
                DOM.aiPopup.style.display = 'flex';
                DOM.aiBtn.classList.add('active');
                showAIOptions();
            }
        };

        function showAIOptions() {
            const brainDiv = document.getElementById('ai-brainstorm-section');
            const textDiv = document.getElementById('ai-text-section');
            
            // Check if a text card is selected
            const selectedCardObj = state.cards.find(c => c.id === state.selectedCard);
            
            if (selectedCardObj && selectedCardObj.type === 'text') {
                brainDiv.classList.add('hidden');
                textDiv.classList.remove('hidden');
            } else {
                brainDiv.classList.remove('hidden');
                textDiv.classList.add('hidden');
            }
        }

        async function runBrainstorm() {
            const topic = document.getElementById('ai-topic-input').value;
            if (!topic) return alert("Inserisci un argomento!");

            setAILoading(true);
            
            const prompt = `Generate 5 distinct, creative ideas about "${topic}". Return strictly a JSON array of strings, like ["Idea 1", "Idea 2", "Idea 3"]. No markdown formatting.`;
            
            const result = await callGemini(prompt, "You are a creative brainstorming assistant. Output strictly JSON.");
            
            if (result) {
                try {
                    // Cleanup potential markdown fences
                    const cleanResult = result.replace(/```json/g, '').replace(/```/g, '').trim();
                    const ideas = JSON.parse(cleanResult);
                    
                    // Center of viewport
                    const rect = DOM.viewport.getBoundingClientRect();
                    const centerX = (-state.pan.x + (rect.width / 2)) / state.scale;
                    const centerY = (-state.pan.y + (rect.height / 2)) / state.scale;

                    // Arrange in a circle
                    const radius = 250;
                    ideas.forEach((idea, i) => {
                        const angle = (i / ideas.length) * Math.PI * 2;
                        const x = centerX + Math.cos(angle) * radius - 100; // -100 is half width
                        const y = centerY + Math.sin(angle) * radius - 75;  // -75 is half height
                        createCard('text', idea, x, y);
                    });
                } catch (e) {
                    console.error("Parsing error", e);
                    alert("Errore nell'interpretare la risposta AI.");
                }
            }
            
            setAILoading(false);
            DOM.aiPopup.style.display = 'none';
        }

        async function runTextAI(mode) {
            const card = state.cards.find(c => c.id === state.selectedCard);
            if (!card) return;

            setAILoading(true);
            
            let prompt = "";
            if (mode === 'expand') prompt = `Expand on this text, adding more detail and context, keep it under 100 words: "${card.content}"`;
            if (mode === 'summarize') prompt = `Summarize this text into 3 key bullet points: "${card.content}"`;
            if (mode === 'professional') prompt = `Rewrite this text to be more professional, polite, and corporate: "${card.content}"`;

            const result = await callGemini(prompt);
            
            if (result) {
                card.content = result;
                // Update DOM
                const el = document.getElementById(`card-${card.id}`);
                const textEl = el.querySelector('.content-text');
                if (textEl) textEl.innerText = result;
            }

            setAILoading(false);
            DOM.aiPopup.style.display = 'none';
        }

        function setAILoading(isLoading) {
            const loading = document.getElementById('ai-loading');
            const sections = [document.getElementById('ai-brainstorm-section'), document.getElementById('ai-text-section')];
            
            if (isLoading) {
                DOM.aiBtn.classList.add('loading');
                loading.classList.remove('hidden');
                sections.forEach(s => s.classList.add('hidden'));
            } else {
                DOM.aiBtn.classList.remove('loading');
                loading.classList.add('hidden');
                // View will be reset by logic or popup close
            }
        }

        // --- Persistence ---

        document.getElementById('btn-save').onclick = () => {
            const data = JSON.stringify({ cards: state.cards, connections: state.connections });
            localStorage.setItem('thinkdesk_save', data);
            alert("Desk salvato nel browser!");
        };

        function loadFromJSON(jsonStr) {
            try {
                const data = JSON.parse(jsonStr);
                DOM.world.innerHTML = '<svg id="connections-layer" width="1" height="1"></svg>';
                DOM.svgLayer = document.getElementById('connections-layer');
                state.cards = [];
                state.connections = [];
                data.cards.forEach(c => createCard(c.type, c.content, c.x, c.y, c.w, c.h, c.id));
                if(data.cards.length > 0) state.nextId = Math.max(...data.cards.map(c => c.id)) + 1;
                state.connections = data.connections || [];
                renderConnections();
            } catch (e) {
                alert("Errore caricamento file.");
                console.error(e);
            }
        }

        const saved = localStorage.getItem('thinkdesk_save');
        if (saved) loadFromJSON(saved);

        document.getElementById('btn-export').onclick = () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify({ cards: state.cards, connections: state.connections }));
            const anchor = document.createElement('a');
            anchor.setAttribute("href", dataStr);
            anchor.setAttribute("download", "desk.json");
            document.body.appendChild(anchor);
            anchor.click();
            anchor.remove();
        };

        document.getElementById('file-input').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => loadFromJSON(ev.target.result);
            reader.readAsText(file);
        };

        // --- Modal / Expand ---
        const modal = document.getElementById('modal-overlay');
        const modalBody = document.getElementById('modal-body');
        
        function openModal(cardData) {
            modal.style.display = 'flex';
            modalBody.innerHTML = '';
            
            if (cardData.type === 'text') {
                const p = document.createElement('p');
                p.style.whiteSpace = 'pre-wrap';
                p.style.fontSize = '1.2rem';
                p.style.lineHeight = '1.6';
                p.innerText = cardData.content;
                modalBody.appendChild(p);
            } else if (cardData.type === 'img') {
                const img = document.createElement('img');
                img.src = cardData.content;
                img.style.maxWidth = '100%';
                img.style.maxHeight = '100%';
                img.style.display = 'block';
                img.style.margin = 'auto';
                modalBody.appendChild(img);
            } else if (cardData.type === 'web') {
                const iframe = document.createElement('iframe');
                iframe.src = cardData.content;
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                modalBody.appendChild(iframe);
            }
        }
        
        document.getElementById('modal-close').onclick = () => { modal.style.display = 'none'; };
        modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };

    </script>
</body>
</html>
