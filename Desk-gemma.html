<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ThinkDesk | AI & Local Files</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base Setup */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #f3f4f6; touch-action: none; font-family: 'Segoe UI', system-ui, sans-serif; }
        
        /* The Viewport */
        #viewport { width: 100vw; height: 100vh; overflow: hidden; position: relative; cursor: grab; }
        #viewport:active { cursor: grabbing; }
        
        /* The World (Transform Layer) */
        #world { position: absolute; top: 0; left: 0; transform-origin: 0 0; will-change: transform; width: 0; height: 0; }
        
        /* SVG Connections Layer */
        #connections-layer { position: absolute; overflow: visible; pointer-events: none; z-index: 0; }
        
        /* Cards */
        .card {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            border: 1px solid #e5e7eb;
            transition: box-shadow 0.2s, border-color 0.2s;
            user-select: none;
            touch-action: none;
            min-width: 150px;
            min-height: 100px;
            z-index: 10;
        }
        
        .card.selected { border: 2px solid #3b82f6; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); z-index: 20; }
        .card-header { height: 28px; background: #f9fafb; border-bottom: 1px solid #e5e7eb; border-radius: 8px 8px 0 0; cursor: move; display: flex; justify-content: space-between; padding: 0 4px; align-items: center; }
        .card-drag-handle { flex: 1; height: 100%; display: flex; align-items: center; padding-left: 6px; color: #9ca3af; font-size: 12px; }
        .card-body { flex: 1; padding: 0; overflow: hidden; position: relative; display: flex; flex-direction: column; }
        .card-resize { position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: se-resize; background: linear-gradient(135deg, transparent 50%, #cbd5e1 50%); border-radius: 0 0 8px 0; z-index: 5; }
        
        /* Content Types */
        .content-text { width: 100%; height: 100%; padding: 8px; outline: none; white-space: pre-wrap; overflow-y: auto; font-size: 14px; cursor: text; background: transparent; }
        .content-img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; background: #f8fafc; }
        /* PDF/Web Cover needed to capture clicks for drag */
        .interaction-cover { position: absolute; inset: 0; z-index: 2; cursor: grab; background: transparent; }
        .content-iframe { width: 100%; height: 100%; border: none; z-index: 1; display: block; background: white; }

        /* Toolbar */
        #toolbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
            padding: 8px 16px; border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            display: flex; gap: 10px; z-index: 1000; border: 1px solid #e5e7eb; align-items: center;
        }
        
        .tool-btn {
            width: 44px; height: 44px; border-radius: 10px; border: none; background: transparent;
            color: #4b5563; font-size: 20px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s; position: relative; flex-shrink: 0;
        }
        
        .tool-btn:hover { background: #f3f4f6; color: #111827; }
        .tool-btn.active { background: #eff6ff; color: #2563eb; }
        
        /* AI Button Special Style */
        #btn-ai { color: #7c3aed; }
        #btn-ai:hover { background: #f5f3ff; color: #6d28d9; }
        #btn-ai.loading { animation: pulse 1.5s infinite; opacity: 0.7; pointer-events: none; }
        
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(0.95); } 100% { transform: scale(1); } }

        /* AI Popup */
        #ai-popup {
            position: fixed; bottom: 85px; left: 50%; transform: translateX(-50%);
            background: white; width: 300px; padding: 16px; border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1001; display: none; flex-direction: column; gap: 10px; border: 1px solid #e5e7eb;
        }
        .ai-option-btn {
            background: #f3f4f6; border: none; padding: 8px; border-radius: 6px; cursor: pointer; text-align: left; font-size: 14px; color: #374151; transition: background 0.2s;
        }
        .ai-option-btn:hover { background: #e5e7eb; }
        .ai-input { width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; margin-bottom: 8px; font-size: 14px; }
        
        /* Modal for expansion */
        #modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 2000; display: none; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        #modal-content { background: white; width: 95%; height: 95%; border-radius: 8px; overflow: hidden; position: relative; display: flex; flex-direction: column; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
        #modal-close { position: absolute; top: 12px; right: 12px; background: rgba(0,0,0,0.1); border: none; width: 36px; height: 36px; border-radius: 50%; cursor: pointer; z-index: 50; font-weight: bold; color: #333; display: flex; align-items: center; justify-content: center; font-size: 18px; }
        #modal-close:hover { background: rgba(0,0,0,0.2); }

        /* Helpers */
        .hidden { display: none !important; }
        .divider { width: 1px; height: 24px; background: #e5e7eb; margin: 0 4px; }
        
        /* Grid Background pattern */
        #grid-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: radial-gradient(#94a3b8 1px, transparent 1px);
            background-size: 24px 24px; opacity: 0.3; pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- Main Viewport -->
    <div id="viewport">
        <div id="grid-bg"></div>
        <div id="world">
            <svg id="connections-layer" width="1" height="1"></svg>
            <!-- Cards go here -->
        </div>
    </div>

    <!-- Toolbar -->
    <div id="toolbar">
        <button class="tool-btn" id="btn-text" title="Aggiungi Testo">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg>
        </button>
        
        <!-- NEW: Upload Button -->
        <button class="tool-btn" id="btn-upload" title="Carica File (IMG/PDF)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></svg>
        </button>
        <!-- Hidden Inputs for File Upload -->
        <input type="file" id="upload-input" class="hidden" accept="image/*,application/pdf">

        <button class="tool-btn" id="btn-web" title="Link Web / Embed">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
        </button>
        
        <div class="divider"></div>

        <!-- AI BUTTON -->
        <button class="tool-btn" id="btn-ai" title="Magic AI ‚ú®">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
        </button>

        <div class="divider"></div>

        <button class="tool-btn" id="btn-connect" title="Modalit√† Connetti">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>
        </button>
        <button class="tool-btn" id="btn-delete-mode" title="Modalit√† Elimina">
             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        </button>
        
        <div class="divider"></div>

        <button class="tool-btn" id="btn-save" title="Salva Desk">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
        </button>
        <button class="tool-btn text-red-500" id="btn-clear" title="Svuota Desk">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
    </div>

    <!-- AI Popup Menu -->
    <div id="ai-popup">
        <h3 class="font-bold text-gray-700 text-sm mb-2">‚ú® Gemini AI Tools</h3>
        
        <!-- Section: No Card Selected (Brainstorming) -->
        <div id="ai-brainstorm-section">
            <p class="text-xs text-gray-500 mb-2">Genera idee su un argomento:</p>
            <input type="text" id="ai-topic-input" class="ai-input" placeholder="Es: Kant e l'Illuminismo...">
            <button class="ai-option-btn w-full bg-indigo-50 text-indigo-700 font-medium" onclick="runBrainstorm()">üöÄ Genera Idee</button>
        </div>

        <!-- Section: Text Card Selected -->
        <div id="ai-text-section" class="hidden">
            <p class="text-xs text-gray-500 mb-2">Modifica la card selezionata:</p>
            <div class="flex flex-col gap-1">
                <button class="ai-option-btn" onclick="runTextAI('expand')">üìù Espandi contenuto</button>
                <button class="ai-option-btn" onclick="runTextAI('summarize')">ü§è Sintesi per punti</button>
                <button class="ai-option-btn" onclick="runTextAI('professional')">üéì Riscrivi Accademico</button>
            </div>
        </div>
        
        <div id="ai-loading" class="hidden text-center py-2 text-indigo-600 text-sm">
            ‚ú® Elaborazione in corso...
        </div>
    </div>

    <!-- Expansion Modal -->
    <div id="modal-overlay">
        <div id="modal-content">
            <button id="modal-close">‚úï</button>
            <div id="modal-body" class="w-full h-full bg-gray-50"></div>
        </div>
    </div>

    <script>
        // --- Gemini Configuration ---
        const apiKey = ""; // Injected automatically
        const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        async function callGemini(prompt, systemInstruction = "Sei un assistente utile e preciso.") {
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] }
            };

            try {
                const response = await fetch(GEMINI_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error("API Error");
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "Errore generazione.";
            } catch (error) {
                console.error(error);
                alert("Errore AI. Controlla la console.");
                return null;
            }
        }

        // --- App State ---
        const state = {
            pan: { x: 0, y: 0 },
            scale: 1,
            mode: 'move', // move, connect, delete
            isDragging: false,
            isPanning: false,
            startPan: { x: 0, y: 0 },
            cards: [],
            connections: [],
            nextId: 1,
            selectedCard: null,
            connectSource: null
        };

        const DOM = {
            viewport: document.getElementById('viewport'),
            world: document.getElementById('world'),
            svgLayer: document.getElementById('connections-layer'),
            grid: document.getElementById('grid-bg'),
            btns: document.querySelectorAll('.tool-btn'),
            aiPopup: document.getElementById('ai-popup'),
            aiBtn: document.getElementById('btn-ai'),
            fileInput: document.getElementById('upload-input')
        };

        // --- Core: Infinite Desk ---
        function updateTransform() {
            DOM.world.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.scale})`;
            DOM.grid.style.backgroundPosition = `${state.pan.x}px ${state.pan.y}px`;
            DOM.grid.style.backgroundSize = `${24 * state.scale}px ${24 * state.scale}px`;
        }

        DOM.viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.ctrlKey || e.metaKey) {
                const delta = -Math.sign(e.deltaY) * 0.1;
                const oldScale = state.scale;
                let newScale = Math.min(Math.max(0.1, state.scale + delta), 5);
                
                const rect = DOM.viewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const worldX = (mouseX - state.pan.x) / oldScale;
                const worldY = (mouseY - state.pan.y) / oldScale;
                
                state.pan.x = mouseX - worldX * newScale;
                state.pan.y = mouseY - worldY * newScale;
                state.scale = newScale;
            } else {
                state.pan.x -= e.deltaX;
                state.pan.y -= e.deltaY;
            }
            updateTransform();
        }, { passive: false });

        DOM.viewport.addEventListener('pointerdown', (e) => {
            if (!DOM.aiPopup.contains(e.target) && e.target !== DOM.aiBtn && !DOM.aiBtn.contains(e.target)) {
                DOM.aiPopup.style.display = 'none';
                DOM.aiBtn.classList.remove('active');
            }

            if (e.target === DOM.viewport || e.target === DOM.grid || e.target.id === 'connections-layer') {
                if(state.selectedCard) {
                    const el = document.getElementById(`card-${state.selectedCard}`);
                    if(el) el.classList.remove('selected');
                    state.selectedCard = null;
                }
                state.isPanning = true;
                state.startPan = { x: e.clientX - state.pan.x, y: e.clientY - state.pan.y };
                DOM.viewport.setPointerCapture(e.pointerId);
            }
        });

        DOM.viewport.addEventListener('pointermove', (e) => {
            if (!state.isPanning) return;
            state.pan.x = e.clientX - state.startPan.x;
            state.pan.y = e.clientY - state.startPan.y;
            updateTransform();
        });

        DOM.viewport.addEventListener('pointerup', (e) => {
            state.isPanning = false;
            DOM.viewport.releasePointerCapture(e.pointerId);
        });

        // --- Card Creation ---
        function createCard(type, content = null, x = null, y = null, w = 240, h = 160, id = null, filename = '') {
            const cardId = id || state.nextId++;
            
            if (x === null) {
                const rect = DOM.viewport.getBoundingClientRect();
                x = (-state.pan.x + (rect.width / 2)) / state.scale - (w / 2);
                y = (-state.pan.y + (rect.height / 2)) / state.scale - (h / 2);
            }

            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.id = `card-${cardId}`;
            cardEl.style.left = `${x}px`;
            cardEl.style.top = `${y}px`;
            cardEl.style.width = `${w}px`;
            cardEl.style.height = `${h}px`;
            cardEl.dataset.id = cardId;

            const cardData = { id: cardId, type, content, x, y, w, h, filename };
            state.cards.push(cardData);

            // Header
            const header = document.createElement('div');
            header.className = 'card-header';
            
            const titleSpan = document.createElement('span');
            titleSpan.className = 'card-drag-handle truncate';
            titleSpan.innerText = filename || (type === 'text' ? 'Nota' : type.toUpperCase());
            titleSpan.style.pointerEvents = 'none'; // allow click through to header
            
            const expandBtn = document.createElement('div');
            expandBtn.innerHTML = '‚§¢';
            expandBtn.style.cursor = 'pointer';
            expandBtn.style.padding = '0 6px';
            expandBtn.style.fontWeight = 'bold';
            expandBtn.title = "Apri";
            expandBtn.onclick = (e) => { e.stopPropagation(); openModal(cardData); };
            
            header.appendChild(titleSpan);
            header.appendChild(expandBtn);
            cardEl.appendChild(header);

            // Body
            const body = document.createElement('div');
            body.className = 'card-body';
            
            if (type === 'text') {
                const textarea = document.createElement('div');
                textarea.className = 'content-text';
                textarea.contentEditable = true;
                textarea.innerText = content || '';
                textarea.addEventListener('pointerdown', (e) => e.stopPropagation());
                textarea.addEventListener('input', () => { cardData.content = textarea.innerText; });
                body.appendChild(textarea);
            } else if (type === 'img') {
                const img = document.createElement('img');
                img.className = 'content-img';
                img.src = content;
                body.appendChild(img);
            } else if (type === 'web' || type === 'pdf') {
                const iframe = document.createElement('iframe');
                iframe.className = 'content-iframe';
                iframe.src = content;
                // Overlay for drag interactions
                const overlay = document.createElement('div');
                overlay.className = 'interaction-cover';
                body.appendChild(iframe);
                body.appendChild(overlay);
            }

            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'card-resize';
            body.appendChild(resizeHandle);
            
            cardEl.appendChild(body);
            DOM.world.appendChild(cardEl);

            // Logic interactions (Select, Move, Connect, Delete)
            setupCardInteractions(cardEl, cardData, header);
            
            return cardData;
        }

        function setupCardInteractions(cardEl, cardData, header) {
            const cardId = cardData.id;

            cardEl.addEventListener('pointerdown', (e) => {
                // Ignore clicks on resize handle
                if (e.target.classList.contains('card-resize')) return;

                // Handle Selection
                if (state.selectedCard && state.selectedCard !== cardId) {
                    document.getElementById(`card-${state.selectedCard}`)?.classList.remove('selected');
                }
                state.selectedCard = cardId;
                cardEl.classList.add('selected');
                
                if(DOM.aiPopup.style.display === 'flex') showAIOptions();

                // Handle Modes
                if(state.mode === 'delete') {
                    e.stopPropagation();
                    deleteCard(cardId);
                    return;
                }
                if(state.mode === 'connect') {
                    e.stopPropagation();
                    handleConnectionStart(cardId, cardEl);
                    return;
                }
            });

            // Dragging (via Header or interaction cover)
            const startDrag = (e) => {
                if (state.mode !== 'move') return;
                
                // Allow text selection inside text cards
                if (e.target.isContentEditable) return;

                e.stopPropagation();
                cardEl.setPointerCapture(e.pointerId);
                const startX = e.clientX;
                const startY = e.clientY;
                const initialLeft = parseFloat(cardEl.style.left);
                const initialTop = parseFloat(cardEl.style.top);

                const onMove = (moveEvent) => {
                    const dx = (moveEvent.clientX - startX) / state.scale;
                    const dy = (moveEvent.clientY - startY) / state.scale;
                    cardEl.style.left = `${initialLeft + dx}px`;
                    cardEl.style.top = `${initialTop + dy}px`;
                    cardData.x = initialLeft + dx;
                    cardData.y = initialTop + dy;
                    updateConnections();
                };

                const onUp = () => {
                    cardEl.removeEventListener('pointermove', onMove);
                    cardEl.removeEventListener('pointerup', onUp);
                    cardEl.releasePointerCapture(e.pointerId);
                };

                cardEl.addEventListener('pointermove', onMove);
                cardEl.addEventListener('pointerup', onUp);
            };

            header.addEventListener('pointerdown', startDrag);
            // Also enable dragging from the cover on web/pdf/img cards
            const cover = cardEl.querySelector('.interaction-cover');
            if(cover) cover.addEventListener('pointerdown', startDrag);
            // Allow drag from image itself
            const img = cardEl.querySelector('.content-img');
            if(img) img.addEventListener('pointerdown', startDrag);

            // Resize Logic
            const resizer = cardEl.querySelector('.card-resize');
            resizer.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                resizer.setPointerCapture(e.pointerId);
                const startX = e.clientX;
                const startY = e.clientY;
                const startW = parseFloat(cardEl.style.width);
                const startH = parseFloat(cardEl.style.height);

                const onResize = (moveEvent) => {
                    const dx = (moveEvent.clientX - startX) / state.scale;
                    const dy = (moveEvent.clientY - startY) / state.scale;
                    const newW = Math.max(150, startW + dx);
                    const newH = Math.max(100, startH + dy);
                    cardEl.style.width = `${newW}px`;
                    cardEl.style.height = `${newH}px`;
                    cardData.w = newW;
                    cardData.h = newH;
                    updateConnections();
                };

                const onUp = () => {
                    resizer.removeEventListener('pointermove', onResize);
                    resizer.removeEventListener('pointerup', onUp);
                    resizer.releasePointerCapture(e.pointerId);
                };

                resizer.addEventListener('pointermove', onResize);
                resizer.addEventListener('pointerup', onUp);
            });
        }

        function deleteCard(id) {
            const el = document.getElementById(`card-${id}`);
            if (el) el.remove();
            state.cards = state.cards.filter(c => c.id !== id);
            state.connections = state.connections.filter(c => c.from !== id && c.to !== id);
            if(state.selectedCard === id) state.selectedCard = null;
            renderConnections();
        }

        // --- Connections ---
        function handleConnectionStart(cardId, cardEl) {
            if (state.connectSource === null) {
                state.connectSource = cardId;
                cardEl.classList.add('selected');
            } else {
                if (state.connectSource !== cardId) addConnection(state.connectSource, cardId);
                document.getElementById(`card-${state.connectSource}`)?.classList.remove('selected');
                state.connectSource = null;
            }
        }

        function addConnection(fromId, toId) {
            const exists = state.connections.find(c => 
                (c.from === fromId && c.to === toId) || (c.from === toId && c.to === fromId)
            );
            if (!exists) {
                state.connections.push({ from: fromId, to: toId, color: '#94a3b8' });
                renderConnections();
            }
        }

        function renderConnections() {
            DOM.svgLayer.innerHTML = '';
            DOM.svgLayer.style.overflow = 'visible'; 
            state.connections.forEach((conn, index) => {
                const c1 = state.cards.find(c => c.id === conn.from);
                const c2 = state.cards.find(c => c.id === conn.to);
                if (!c1 || !c2) return;
                
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", c1.x + c1.w / 2);
                line.setAttribute("y1", c1.y + c1.h / 2);
                line.setAttribute("x2", c2.x + c2.w / 2);
                line.setAttribute("y2", c2.y + c2.h / 2);
                line.setAttribute("stroke", conn.color);
                line.setAttribute("stroke-width", "3");
                line.style.cursor = "pointer";
                line.onclick = (e) => {
                    if (state.mode === 'delete') {
                        e.stopPropagation();
                        state.connections.splice(index, 1);
                        renderConnections();
                    }
                };
                DOM.svgLayer.appendChild(line);
            });
        }
        function updateConnections() { requestAnimationFrame(renderConnections); }

        // --- Toolbar & Tools ---
        function setMode(mode) {
            state.mode = mode;
            DOM.btns.forEach(b => b.classList.remove('active'));
            if (mode === 'connect') document.getElementById('btn-connect').classList.add('active');
            if (mode === 'delete') document.getElementById('btn-delete-mode').classList.add('active');
            DOM.viewport.style.cursor = mode === 'delete' ? 'crosshair' : 'grab';
            if (mode !== 'connect' && state.connectSource) {
                 document.getElementById(`card-${state.connectSource}`)?.classList.remove('selected');
                 state.connectSource = null;
            }
        }

        document.getElementById('btn-text').onclick = () => { setMode('move'); createCard('text'); };
        
        document.getElementById('btn-web').onclick = () => {
            setMode('move');
            const url = prompt("Inserisci URL pagina (es. Wikipedia) o Video:", "https://it.wikipedia.org/wiki/Immanuel_Kant");
            if (url) createCard('web', url, null, null, 300, 200, null, 'Web Link');
        };

        // --- FILE UPLOAD LOGIC ---
        document.getElementById('btn-upload').onclick = () => {
            setMode('move');
            DOM.fileInput.click();
        };

        DOM.fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            
            reader.onload = (event) => {
                const result = event.target.result; // This is the Base64 string
                const type = file.type.startsWith('image/') ? 'img' : 'pdf';
                
                // Determine dimensions based on type
                const w = type === 'img' ? 300 : 250;
                const h = type === 'img' ? 220 : 300;
                
                createCard(type, result, null, null, w, h, null, file.name);
                
                // Reset input so same file can be selected again if deleted
                DOM.fileInput.value = ''; 
            };

            if (file.type === 'application/pdf' || file.type.startsWith('image/')) {
                reader.readAsDataURL(file);
            } else {
                alert("Formato non supportato. Usa solo Immagini o PDF.");
            }
        };

        document.getElementById('btn-connect').onclick = () => setMode(state.mode === 'connect' ? 'move' : 'connect');
        document.getElementById('btn-delete-mode').onclick = () => setMode(state.mode === 'delete' ? 'move' : 'delete');
        
        document.getElementById('btn-clear').onclick = () => {
            if(confirm("Attenzione: questo canceller√† tutto. Confermi?")) {
                DOM.world.innerHTML = '<svg id="connections-layer" width="1" height="1"></svg>';
                DOM.svgLayer = document.getElementById('connections-layer');
                state.cards = [];
                state.connections = [];
                state.pan = {x: 0, y: 0};
                state.scale = 1;
                updateTransform();
            }
        };

        // --- AI Logic ---
        DOM.aiBtn.onclick = (e) => {
            e.stopPropagation();
            const isOpen = DOM.aiPopup.style.display === 'flex';
            if(isOpen) {
                DOM.aiPopup.style.display = 'none';
                DOM.aiBtn.classList.remove('active');
            } else {
                DOM.aiPopup.style.display = 'flex';
                DOM.aiBtn.classList.add('active');
                showAIOptions();
            }
        };

        function showAIOptions() {
            const brainDiv = document.getElementById('ai-brainstorm-section');
            const textDiv = document.getElementById('ai-text-section');
            const selectedCardObj = state.cards.find(c => c.id === state.selectedCard);
            
            if (selectedCardObj && selectedCardObj.type === 'text') {
                brainDiv.classList.add('hidden');
                textDiv.classList.remove('hidden');
            } else {
                brainDiv.classList.remove('hidden');
                textDiv.classList.add('hidden');
            }
        }

        async function runBrainstorm() {
            const topic = document.getElementById('ai-topic-input').value;
            if (!topic) return alert("Inserisci un argomento!");
            setAILoading(true);
            const prompt = `Generate 5 distinct, concise concepts/ideas about "${topic}". Return strictly a JSON array of strings. Language: Italian.`;
            const result = await callGemini(prompt, "You are a brainstorming assistant. Output strictly JSON.");
            
            if (result) {
                try {
                    const cleanResult = result.replace(/```json/g, '').replace(/```/g, '').trim();
                    const ideas = JSON.parse(cleanResult);
                    const rect = DOM.viewport.getBoundingClientRect();
                    const cx = (-state.pan.x + rect.width / 2) / state.scale;
                    const cy = (-state.pan.y + rect.height / 2) / state.scale;
                    const radius = 220;
                    ideas.forEach((idea, i) => {
                        const angle = (i / ideas.length) * Math.PI * 2;
                        createCard('text', idea, cx + Math.cos(angle)*radius - 120, cy + Math.sin(angle)*radius - 80, 240, 160);
                    });
                } catch (e) { alert("Errore AI. Riprova."); }
            }
            setAILoading(false);
            DOM.aiPopup.style.display = 'none';
        }

        async function runTextAI(mode) {
            const card = state.cards.find(c => c.id === state.selectedCard);
            if (!card) return;
            setAILoading(true);
            let prompt = "";
            if (mode === 'expand') prompt = `Espandi questa nota aggiungendo dettagli e contesto storico/filosofico se pertinente: "${card.content}"`;
            if (mode === 'summarize') prompt = `Riassumi in 3 punti chiave essenziali: "${card.content}"`;
            if (mode === 'professional') prompt = `Riscrivi con tono accademico/professionale, preciso e senza fronzoli: "${card.content}"`;

            const result = await callGemini(prompt);
            if (result) {
                card.content = result;
                const el = document.getElementById(`card-${card.id}`);
                const textEl = el.querySelector('.content-text');
                if (textEl) textEl.innerText = result;
            }
            setAILoading(false);
            DOM.aiPopup.style.display = 'none';
        }

        function setAILoading(isLoading) {
            const loading = document.getElementById('ai-loading');
            const sections = [document.getElementById('ai-brainstorm-section'), document.getElementById('ai-text-section')];
            if (isLoading) {
                DOM.aiBtn.classList.add('loading');
                loading.classList.remove('hidden');
                sections.forEach(s => s.classList.add('hidden'));
            } else {
                DOM.aiBtn.classList.remove('loading');
                loading.classList.add('hidden');
            }
        }

        // --- Save/Load System ---
        document.getElementById('btn-save').onclick = () => {
            try {
                const data = JSON.stringify({ cards: state.cards, connections: state.connections });
                localStorage.setItem('thinkdesk_save', data);
                alert("Salvato! (Attenzione: svuota la cache se il browser rallenta)");
            } catch (e) {
                alert("Errore salvataggio: Limite memoria browser raggiunto. Riduci le immagini.");
            }
        };

        const saved = localStorage.getItem('thinkdesk_save');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                state.cards = []; state.connections = [];
                data.cards.forEach(c => createCard(c.type, c.content, c.x, c.y, c.w, c.h, c.id, c.filename));
                if(data.cards.length > 0) state.nextId = Math.max(...data.cards.map(c => c.id)) + 1;
                state.connections = data.connections || [];
                renderConnections();
            } catch(e) { console.error("Save corrupted"); }
        }

        // --- Modal ---
        const modal = document.getElementById('modal-overlay');
        const modalBody = document.getElementById('modal-body');
        
        function openModal(cardData) {
            modal.style.display = 'flex';
            modalBody.innerHTML = '';
            
            if (cardData.type === 'text') {
                const p = document.createElement('div');
                p.className = 'p-8 text-lg leading-relaxed h-full overflow-auto';
                p.innerText = cardData.content;
                modalBody.appendChild(p);
            } else if (cardData.type === 'img') {
                const img = document.createElement('img');
                img.src = cardData.content;
                img.style.width = '100%'; img.style.height = '100%'; img.style.objectFit = 'contain';
                modalBody.appendChild(img);
            } else if (cardData.type === 'web' || cardData.type === 'pdf') {
                const iframe = document.createElement('iframe');
                iframe.src = cardData.content;
                iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = 'none';
                modalBody.appendChild(iframe);
            }
        }
        document.getElementById('modal-close').onclick = () => { modal.style.display = 'none'; };
        modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };

    </script>
</body>
</html>
